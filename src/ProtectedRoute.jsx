// src/auth/ProtectedRoute.jsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from './auth/AuthProvider'; // Убедитесь, что путь к AuthProvider верный

/**
 * Компонент-обертка для защиты маршрутов React Router.
 * Проверяет, аутентифицирован ли пользователь и имеет ли он необходимую роль.
 *
 * @param {object} props - Пропсы компонента.
 * @param {React.ReactNode} props.children - Дочерний компонент (защищаемая страница), который будет отрендерен при успешной проверке.
 * @param {string[]} props.allowedRoles - Массив строк с ролями, которым разрешен доступ к этому маршруту.
 */
const ProtectedRoute = ({ children, allowedRoles }) => {
  // 1. Получаем состояние аутентификации и данные пользователя из контекста
  const { user, isLoading } = useAuth();
  // 2. Получаем текущее местоположение для возможного редиректа обратно после логина
  const location = useLocation();

  // 3. Проверяем, завершилась ли инициализация аутентификации (проверка localStorage)
  if (isLoading) {
    // Если проверка еще идет, показываем заглушку или лоадер.
    // Это предотвращает преждевременный редирект до того, как пользователь будет восстановлен из localStorage.
    console.log("ProtectedRoute: Ожидание завершения инициализации AuthProvider...");
    // Можно вернуть полноценный компонент-лоадер или просто текст/null
    return <div>Загрузка данных пользователя...</div>; // <-- Замените на ваш компонент лоадера, если есть
  }

  // 4. Проверка аутентификации (после завершения isLoading)
  if (!user) {
    // Если пользователя нет (не залогинен), перенаправляем на страницу входа (/auth).
    console.log(`ProtectedRoute: Пользователь не аутентифицирован. Перенаправление на /auth с ${location.pathname}`);
    // Передаем текущий путь в state, чтобы после логина можно было вернуться сюда.
    // `replace` заменяет текущую запись в истории навигации, чтобы кнопка "назад" не возвращала на защищенную страницу.
    return <Navigate to="/auth" state={{ from: location }} replace />;
  }

  // 5. Проверка авторизации (роли пользователя)
  // Проверяем, передан ли массив allowedRoles и есть ли у пользователя поле role.
  // Затем проверяем, входит ли роль пользователя в список разрешенных ролей.
  if (!allowedRoles || !Array.isArray(allowedRoles) || allowedRoles.length === 0) {
      // Если allowedRoles не передан или пуст, считаем, что доступ разрешен любому аутентифицированному пользователю.
      // Если же вы хотите требовать явного указания ролей всегда, можно здесь выдать ошибку или запретить доступ.
      console.log(`ProtectedRoute: Роли не указаны (allowedRoles пуст), разрешаем доступ для ${user.login}`);
  } else if (!user.role || !allowedRoles.includes(user.role)) {
    // Если роль пользователя не найдена или не входит в список разрешенных,
    // перенаправляем на другую страницу (например, главную или страницу "Доступ запрещен").
    // ВАЖНО: Не перенаправлять на /auth, т.к. пользователь уже аутентифицирован.
    console.warn(`ProtectedRoute: Доступ запрещен для роли "${user.role}". Разрешенные роли: [${allowedRoles.join(', ')}]. Перенаправление на /`);
    // Можно перенаправить на специальную страницу /unauthorized
    // return <Navigate to="/unauthorized" replace />;
    return <Navigate to="/" replace />; // Перенаправляем на главную страницу
  }

  // 6. Доступ разрешен
  // Если все проверки пройдены (пользователь залогинен и его роль подходит),
  // рендерим дочерний компонент (защищаемую страницу).
  console.log(`ProtectedRoute: Доступ разрешен для ${user.login} (роль: ${user.role}) к ${location.pathname}`);
  return children;
};

export default ProtectedRoute;